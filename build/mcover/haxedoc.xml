<haxe>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="massive.mcover.data.AbstractNode" params="" file="src/massive/mcover/data/AbstractNode.hx">
		<id public="1"><t path="Null"><c path="Int"/></t></id>
		<name public="1"><c path="String"/></name>
		<resultCache><t path="massive.mcover.data.CoverageResult"/></resultCache>
		<getResults public="1" set="method" line="43"><f a="?cache">
	<e path="Bool"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></getResults>
		<getPercentage public="1" set="method" line="53"><f a=""><c path="Float"/></f></getPercentage>
		<getClasses public="1" set="method" line="69"><f a=""><c path="Array"><c path="massive.mcover.data.Clazz"/></c></f></getClasses>
		<lookupBranch public="1" set="method" line="74"><f a="path">
	<c path="Array"><c path="Int"/></c>
	<c path="massive.mcover.data.Branch"/>
</f></lookupBranch>
		<lookupStatement public="1" set="method" line="79"><f a="path">
	<c path="Array"><c path="Int"/></c>
	<c path="massive.mcover.data.Statement"/>
</f></lookupStatement>
		<getMissingBranches public="1" set="method" line="85"><f a=""><c path="Array"><c path="massive.mcover.data.Branch"/></c></f></getMissingBranches>
		<getMissingStatements public="1" set="method" line="90"><f a=""><c path="Array"><c path="massive.mcover.data.Statement"/></c></f></getMissingStatements>
		<emptyResult set="method" line="98"><f a=""><t path="massive.mcover.data.CoverageResult"/></f></emptyResult>
		<hxSerialize set="method" line="103"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize set="method" line="109"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.mcover.data.AbstractNodeList" params="" file="src/massive/mcover/data/AbstractNodeList.hx">
		<extends path="massive.mcover.data.AbstractNode"/>
		<itemsById><c path="IntHash"><c path="massive.mcover.data.AbstractNode"/></c></itemsById>
		<items><c path="Hash"><c path="Int"/></c></items>
		<itemCount public="1" set="null"><c path="Int"/></itemCount>
		<getItemByName public="1" set="method" line="48"><f a="name:cls">
	<c path="String"/>
	<c path="Class"><c path="massive.mcover.data.AbstractNode"/></c>
	<c path="massive.mcover.data.AbstractNode"/>
</f></getItemByName>
		<lookupBranch public="1" set="method" line="61" override="1"><f a="path">
	<c path="Array"><c path="Int"/></c>
	<c path="massive.mcover.data.Branch"/>
</f></lookupBranch>
		<lookupStatement public="1" set="method" line="68" override="1"><f a="path">
	<c path="Array"><c path="Int"/></c>
	<c path="massive.mcover.data.Statement"/>
</f></lookupStatement>
		<getMissingBranches public="1" set="method" line="76" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Branch"/></c></f></getMissingBranches>
		<getMissingStatements public="1" set="method" line="87" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Statement"/></c></f></getMissingStatements>
		<getClasses public="1" set="method" line="98" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Clazz"/></c></f></getClasses>
		<getResults public="1" set="method" line="110" override="1"><f a="?cache">
	<e path="Bool"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></getResults>
		<appendResults set="method" line="127"><f a="to:from">
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></appendResults>
		<hxSerialize set="method" line="146" override="1"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize set="method" line="154" override="1"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new public="1" set="method" line="40"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.haxe.Exception" params="" file="/usr/lib/haxe/lib/mlib/0,3,0,1/massive/haxe/Exception.hx">
		<type public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The exception type. 
	 * 
	 * Should be the fully qualified name of the Exception class. e.g. 'massive.io.IOException'
	 </haxe_doc>
		</type>
		<message public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * A description of the exception
	 </haxe_doc>
		</message>
		<info public="1" set="null">
			<t path="haxe.PosInfos"/>
			<haxe_doc>
	 * The pos infos from where the exception was created.
	 </haxe_doc>
		</info>
		<toString public="1" set="method" line="78">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[
	 * Returns a string representation of this exception.
	 * 
	 * Format: <type>: <message> at <className>#<methodName> (<lineNumber>)
	 ]]></haxe_doc>
		</toString>
		<new public="1" set="method" line="66">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * @param	message			a description of the exception
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Instances of the class Exception and its subclasses, when thrown, provide information about
 * the type and location of erroneous behavior.
 * 
 * An application should lookout for and handle raised exceptions through try/catch blocks located
 * in an appropriate place.
 * 
 * @author Mike Stead
 </haxe_doc>
	</class>
	<enum path="haxe.StackItem" params="" file="/usr/lib/haxe/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>
	Elements return by [Stack] methods.
</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="/usr/lib/haxe/std/haxe/Stack.hx">
		<callStack public="1" set="method" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the call stack elements.
	</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="69" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		catched.
	</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="100" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of the stack as a printable string.
	</haxe_doc>
		</toString>
		<itemToString set="method" line="109" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack set="method" line="135" static="1"><f a="s">
	<unknown/>
	<unknown/>
</f></makeStack>
		<haxe_doc>
	Get informations about the call stack.
</haxe_doc>
	</class>
	<class path="massive.munit.util.MathUtil" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/util/MathUtil.hx">
		<round public="1" set="method" line="48" static="1">
			<f a="value:precision">
				<c path="Float"/>
				<c path="Int"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Round a floating point number to a given decimal place.
	 * 
	 * @param	value			number to round up
	 * @param	precision		precision to round the value to
	 * @return	the rounded value
	 </haxe_doc>
		</round>
		<new public="1" set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * Utility class for math related operations.
 * 
 * @author Mike Stead
 </haxe_doc>
	</class>
	<class path="massive.munit.util.Timer" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/util/Timer.hx">
		<delay public="1" set="method" line="136" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="massive.munit.util.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="151" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 *	Returns a timestamp, in seconds
	 </haxe_doc>
		</stamp>
		<id><t path="Null"><c path="Int"/></t></id>
		<stop public="1" set="method" line="87"><f a=""><e path="Void"/></f></stop>
		<run public="1" set="dynamic" line="113"><f a=""><e path="Void"/></f></run>
		<new public="1" set="method" line="69"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="massive.munit.ITestResultClient" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/ITestResultClient.hx" interface="1">
		<completionHandler public="1" get="get_completeHandler" set="set_completeHandler">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Handler which if present, should be called when the client has completed its processing of the results.
	 </haxe_doc>
		</completionHandler>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The unique identifier for the client.
	 </haxe_doc>
		</id>
		<addPass public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test passes.
	 *  
	 * @param	result			a passed test result
	 </haxe_doc>
		</addPass>
		<addFail public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test fails.
	 *  
	 * @param	result			a failed test result
	 </haxe_doc>
		</addFail>
		<addError public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result
	 </haxe_doc>
		</addError>
		<addIgnore public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test has been ignored.
	 *
	 * @param	result			an ignored test
	 </haxe_doc>
		</addIgnore>
		<reportFinalStatistics public="1" set="method">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
			</f>
			<haxe_doc>
	 * Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data if any
	 </haxe_doc>
		</reportFinalStatistics>
		<haxe_doc><![CDATA[
 * Interface which all test result clients should adhere to.
 * <p>
 * A test result client is responsible for interpreting the results of tests as
 * they are executed by a test runner.
 * </p>
 * 
 * @author Mike Stead
 * @see TestRunner
 ]]></haxe_doc>
	</class>
	<class path="massive.munit.client.PrintClient" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/client/PrintClient.hx">
		<implements path="massive.munit.ITestResultClient"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="62" static="1">
			<c path="String"/>
			<haxe_doc>
	 * Default id of this client.
	 </haxe_doc>
		</DEFAULT_ID>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The unique identifier for the client.
	 </haxe_doc>
		</id>
		<completionHandler public="1" get="get_completeHandler" set="set_completeHandler">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Handler which if present, is called when the client has completed generating its results.
	 </haxe_doc>
		</completionHandler>
		<get_completeHandler set="method" line="73"><f a=""><f a="">
	<c path="massive.munit.ITestResultClient"/>
	<e path="Void"/>
</f></f></get_completeHandler>
		<set_completeHandler set="method" line="77"><f a="value">
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
</f></set_completeHandler>
		<newline public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[
	 * Newline delimiter. Defaults to '\n' for all platforms except 'js' where it defaults to '<br/>'.
	 * 
	 * <p>
	 * Should be set before the client is passed to a test runner.
	 * </p>
	 ]]></haxe_doc>
		</newline>
		<failures><c path="String"/></failures>
		<errors><c path="String"/></errors>
		<ignored><c path="String"/></ignored>
		<output set="null"><c path="String"/></output>
		<currentTestClass><c path="String"/></currentTestClass>
		<originalTrace><d/></originalTrace>
		<includeIgnoredReport><e path="Bool"/></includeIgnoredReport>
		<init set="method" line="124"><f a=""><e path="Void"/></f></init>
		<addPass public="1" set="method" line="173">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test passes.
	 *  
	 * @param	result			a passed test result
	 </haxe_doc>
		</addPass>
		<addFail public="1" set="method" line="184">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test fails.
	 *  
	 * @param	result			a failed test result
	 </haxe_doc>
		</addFail>
		<addError public="1" set="method" line="195">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result
	 </haxe_doc>
		</addError>
		<addIgnore public="1" set="method" line="206">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when a test has been ignored.
	 *
	 * @param	result			an ignored test
	 </haxe_doc>
		</addIgnore>
		<reportFinalStatistics public="1" set="method" line="225">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
			</f>
			<haxe_doc>
	 * Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data
	 </haxe_doc>
		</reportFinalStatistics>
		<checkForNewTestClass set="method" line="244"><f a="result">
	<c path="massive.munit.TestResult"/>
	<e path="Void"/>
</f></checkForNewTestClass>
		<printExceptions set="method" line="256"><f a=""><e path="Void"/></f></printExceptions>
		<print set="method" line="270"><f a="value:?level">
	<d/>
	<e path="massive.munit.client.PrintLevel"/>
	<e path="Void"/>
</f></print>
		<serialiseToHTML set="method" line="302"><f a="value:level">
	<d/>
	<e path="massive.munit.client.PrintLevel"/>
	<c path="String"/>
</f></serialiseToHTML>
		<customTrace set="method" line="350"><f a="value:?info">
	<unknown/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></customTrace>
		<new public="1" set="method" line="115"><f a="?includeIgnoredReport">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * Generates basic text formatted test result output.
 * 
 * <p>
 * Example output:
 * </p>
 * <pre>
 * MUnit Results
 * ------------------------------
 * 
 * Class: SampleTest ...
 * Class: sub.ItemTest ..
 * 
 * PASSED
 * Tests: 5  Passed: 5  Failed: 0 Errors: 0 Ignored: 0 Time: 0.202
 * ==============================
 * </pre>
 * 
 * @author Mike Stead
 ]]></haxe_doc>
	</class>
	<class path="massive.mcover.munit.client.MCoverPrintClient" params="" file="src/massive/mcover/munit/client/MCoverPrintClient.hx">
		<extends path="massive.munit.client.PrintClient"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="54" static="1">
			<c path="String"/>
			<haxe_doc>
	 * Default id of this client.
	 </haxe_doc>
		</DEFAULT_ID>
		<coverage><c path="massive.mcover.CoverageLogger"/></coverage>
		<coverClient><c path="massive.mcover.client.PrintClient"/></coverClient>
		<includeMissingBlocks public="1" set="set_includeMissingBlocks"><e path="Bool"/></includeMissingBlocks>
		<set_includeMissingBlocks set="method" line="61"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_includeMissingBlocks>
		<includeBlockExecutionCounts public="1" set="set_includeBlockExecutionCounts"><e path="Bool"/></includeBlockExecutionCounts>
		<set_includeBlockExecutionCounts set="method" line="69"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_includeBlockExecutionCounts>
		<reportFinalStatistics public="1" set="method" line="110" override="1">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
			</f>
			<haxe_doc>
	 * Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data if any
	 </haxe_doc>
		</reportFinalStatistics>
		<checkForNewTestClass set="method" line="124" override="1"><f a="result">
	<c path="massive.munit.TestResult"/>
	<e path="Void"/>
</f></checkForNewTestClass>
		<printCoverage set="method" line="136"><f a=""><e path="Void"/></f></printCoverage>
		<new public="1" set="method" line="80">
			<f a="?includeIgnoredReport">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * @param	client				the test result client to decorate
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Decorates other ITestResultClient's, adding behavior to include code coverage results
 * 
 * @author Dominic De Lorenzo
 </haxe_doc>
	</class>
	<class path="massive.mcover.data.Clazz" params="" file="src/massive/mcover/data/Clazz.hx">
		<extends path="massive.mcover.data.AbstractNodeList"/>
		<appendResults set="method" line="38" override="1"><f a="to:from">
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></appendResults>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.mcover.CoverageReportClient" params="" file="src/massive/mcover/CoverageReportClient.hx" interface="1">
		<completionHandler public="1">
			<f a="">
				<c path="massive.mcover.CoverageReportClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Handler which if present, should be called when the client has completed its processing of the results.
	 </haxe_doc>
		</completionHandler>
		<report public="1" set="method">
			<f a="allClasses">
				<c path="massive.mcover.data.AllClasses"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when all tests are complete.
	 *  
	 * @param	allClasses	arrgregated coverage data containing all statements, branches orded by package/file/class/method
	 * @see massive.mcover.data.AllClasses;
	 </haxe_doc>
		</report>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.mcover.client.PrintClient" params="" file="src/massive/mcover/client/PrintClient.hx">
		<implements path="massive.mcover.CoverageReportClient"/>
		<completionHandler public="1">
			<f a="">
				<c path="massive.mcover.CoverageReportClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Handler which if present, is called when the client has completed generating its results.
	 </haxe_doc>
		</completionHandler>
		<includeMissingBlocks public="1"><e path="Bool"/></includeMissingBlocks>
		<includeBlockExecutionCounts public="1"><e path="Bool"/></includeBlockExecutionCounts>
		<newline public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[
	 * Newline delimiter. Defaults to '\n' for all platforms except 'js' where it defaults to '<br/>'.
	 * 
	 * <p>
	 * Should be set before the client is passed to a test runner.
	 * </p>
	 ]]></haxe_doc>
		</newline>
		<output public="1" set="null"><c path="String"/></output>
		<divider><c path="String"/></divider>
		<tab><c path="String"/></tab>
		<packageTotal><c path="Int"/></packageTotal>
		<packageCompletedCount><c path="Int"/></packageCompletedCount>
		<packagePartialCount><c path="Int"/></packagePartialCount>
		<classTotal><c path="Int"/></classTotal>
		<classCompletedCount><c path="Int"/></classCompletedCount>
		<classPartialCount><c path="Int"/></classPartialCount>
		<allClasses><c path="massive.mcover.data.AllClasses"/></allClasses>
		<report public="1" set="method" line="83"><f a="allClasses">
	<c path="massive.mcover.data.AllClasses"/>
	<e path="Void"/>
</f></report>
		<reportComplete set="method" line="94"><f a=""><e path="Void"/></f></reportComplete>
		<printReport set="method" line="102"><f a=""><e path="Void"/></f></printReport>
		<printSummary set="method" line="128"><f a=""><e path="Void"/></f></printSummary>
		<printPackageResults set="method" line="155"><f a=""><e path="Void"/></f></printPackageResults>
		<printClassResults set="method" line="179"><f a=""><e path="Void"/></f></printClassResults>
		<printMissingBlocks set="method" line="207">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	* Prints summary of branches and statements that have not been executed
	</haxe_doc>
		</printMissingBlocks>
		<printBlockFrequency set="method" line="253">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	* Outputs all branch and statement logs sorted by highest frequency.
	* For branches reports also totals for true/false  
	</haxe_doc>
		</printBlockFrequency>
		<print set="method" line="331"><f a="value">
	<d/>
	<e path="Void"/>
</f></print>
		<printToTabs set="method" line="336"><f a="args:?columnWidth">
	<c path="Array"><d/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></printToTabs>
		<new public="1" set="method" line="71"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.mcover.client.TraceClient" params="" file="src/massive/mcover/client/TraceClient.hx">
		<extends path="massive.mcover.client.PrintClient"/>
		<printReport set="method" line="40" override="1"><f a=""><e path="Void"/></f></printReport>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="59">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="75">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="89">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="massive.munit.MUnitException" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/MUnitException.hx">
		<extends path="massive.haxe.Exception"/>
		<new public="1" set="method" line="47">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Class constructor.
	 * 
	 * @param	message			a description of the exception
	 * @param	info			pos infos from where the exception was thrown
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Base exception type for all exceptions raised by munit.
 * 
 * @author Mike Stead
 </haxe_doc>
	</class>
	<class path="massive.munit.AssertionException" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/AssertionException.hx">
		<extends path="massive.munit.MUnitException"/>
		<new public="1" set="method" line="46">
			<f a="msg:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * @param	msg				message describing the assertion which failed
	 * @param	info			pos infos of where the failing assertion was made
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Exception thrown when an assertion is made which is not correct.
 *  
 * @author Mike Stead
 * @see Assert
 </haxe_doc>
	</class>
	<class path="massive.mcover.data.AbstractBlock" params="" file="src/massive/mcover/data/AbstractBlock.hx">
		<extends path="massive.mcover.data.AbstractNode"/>
		<file public="1"><c path="String"/></file>
		<packageName public="1"><c path="String"/></packageName>
		<className public="1"><c path="String"/></className>
		<qualifiedClassName public="1"><c path="String"/></qualifiedClassName>
		<methodName public="1"><c path="String"/></methodName>
		<min public="1"><c path="Int"/></min>
		<max public="1"><c path="Int"/></max>
		<location public="1"><c path="String"/></location>
		<lookup public="1"><c path="Array"><c path="Int"/></c></lookup>
		<isCovered public="1" set="method" line="56"><f a=""><e path="Bool"/></f></isCovered>
		<toString public="1" set="method" line="61"><f a=""><c path="String"/></f></toString>
		<hxSerialize set="method" line="66" override="1"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize set="method" line="80" override="1"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new set="method" line="51"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
* Reprents a unique code block {} within an application
* Contains a number of properties relating to it's location and context.
</haxe_doc>
	</class>
	<class path="massive.mcover.data.Branch" params="" file="src/massive/mcover/data/Branch.hx">
		<extends path="massive.mcover.data.AbstractBlock"/>
		<trueCount public="1"><c path="Int"/></trueCount>
		<falseCount public="1"><c path="Int"/></falseCount>
		<totalCount public="1" get="get_totalCount" set="null"><c path="Int"/></totalCount>
		<get_totalCount set="method" line="45"><f a=""><c path="Int"/></f></get_totalCount>
		<isCovered public="1" set="method" line="50" override="1"><f a=""><e path="Bool"/></f></isCovered>
		<toString public="1" set="method" line="55" override="1"><f a=""><c path="String"/></f></toString>
		<hxSerialize set="method" line="71" override="1"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize set="method" line="78" override="1"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new public="1" set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<typedef path="massive.mcover.data.BranchResult" params="" file="src/massive/mcover/data/Branch.hx" module="massive.mcover.data.Branch"><a>
	<trueCount><c path="Int"/></trueCount>
	<total><c path="Int"/></total>
	<id><c path="Int"/></id>
	<falseCount><c path="Int"/></falseCount>
</a></typedef>
	<class path="massive.haxe.util.ReflectUtil" params="" file="/usr/lib/haxe/lib/mlib/0,3,0,1/massive/haxe/util/ReflectUtil.hx">
		<here public="1" set="method" line="43" static="1">
			<f a="?info">
				<t path="haxe.PosInfos"/>
				<t path="haxe.PosInfos"/>
			</f>
			<haxe_doc>
	 * Return information about the location this method is called.
	 </haxe_doc>
		</here>
		<haxe_doc>
 * Utility class to help with reflection.
 * 
 * @author Mike Stead
 </haxe_doc>
	</class>
	<class path="massive.mcover.data.File" params="" file="src/massive/mcover/data/File.hx">
		<extends path="massive.mcover.data.AbstractNodeList"/>
		<getClasses public="1" set="method" line="38" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Clazz"/></c></f></getClasses>
		<appendResults set="method" line="51" override="1"><f a="to:from">
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></appendResults>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="Date" params="" file="/usr/lib/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="225" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="253" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="292" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="207"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="221"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="massive.mcover.macro.CoverClassMacro" params="" file="src/massive/mcover/macro/CoverClassMacro.hx"><haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc></class>
	<class path="Std" params="" file="/usr/lib/haxe/std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<class path="massive.mcover.data.AllClasses" params="" file="src/massive/mcover/data/AllClasses.hx">
		<extends path="massive.mcover.data.AbstractNodeList"/>
		<statements><c path="IntHash"><c path="Array"><c path="Int"/></c></c></statements>
		<branches><c path="IntHash"><c path="Array"><c path="Int"/></c></c></branches>
		<statementResultsById public="1" set="null"><c path="IntHash"><c path="Int"/></c></statementResultsById>
		<branchResultsById public="1" set="null"><c path="IntHash"><t path="massive.mcover.data.BranchResult"/></c></branchResultsById>
		<setStatementResultsHash public="1" set="method" line="58"><f a="hash">
	<c path="IntHash"><c path="Int"/></c>
	<e path="Void"/>
</f></setStatementResultsHash>
		<setBranchResultsHash public="1" set="method" line="63"><f a="hash">
	<c path="IntHash"><t path="massive.mcover.data.BranchResult"/></c>
	<e path="Void"/>
</f></setBranchResultsHash>
		<addStatement public="1" set="method" line="68"><f a="block">
	<c path="massive.mcover.data.Statement"/>
	<e path="Void"/>
</f></addStatement>
		<addBranch public="1" set="method" line="84"><f a="block">
	<c path="massive.mcover.data.Branch"/>
	<e path="Void"/>
</f></addBranch>
		<verifyBlockData set="method" line="100"><f a="block">
	<c path="massive.mcover.data.AbstractBlock"/>
	<e path="Void"/>
</f></verifyBlockData>
		<getBranchById public="1" set="method" line="109"><f a="id">
	<c path="Int"/>
	<c path="massive.mcover.data.Branch"/>
</f></getBranchById>
		<getStatementById public="1" set="method" line="118"><f a="id">
	<c path="Int"/>
	<c path="massive.mcover.data.Statement"/>
</f></getStatementById>
		<getMissingBranches public="1" set="method" line="127" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Branch"/></c></f></getMissingBranches>
		<getMissingStatements public="1" set="method" line="134" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Statement"/></c></f></getMissingStatements>
		<getClasses public="1" set="method" line="141" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Clazz"/></c></f></getClasses>
		<getClassByName public="1" set="method" line="148"><f a="name">
	<c path="String"/>
	<c path="massive.mcover.data.Clazz"/>
</f></getClassByName>
		<getPackages public="1" set="method" line="173"><f a=""><c path="Array"><c path="massive.mcover.data.Package"/></c></f></getPackages>
		<getResults public="1" set="method" line="185" override="1"><f a="?cache">
	<e path="Bool"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></getResults>
		<appendResults set="method" line="224" override="1"><f a="to:from">
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></appendResults>
		<sortOnNodeId set="method" line="234"><f a="a:b">
	<c path="massive.mcover.data.AbstractNode"/>
	<c path="massive.mcover.data.AbstractNode"/>
	<c path="Int"/>
</f></sortOnNodeId>
		<sortOnClazzId set="method" line="239"><f a="a:b">
	<c path="massive.mcover.data.Clazz"/>
	<c path="massive.mcover.data.Clazz"/>
	<c path="Int"/>
</f></sortOnClazzId>
		<sortOnPackageId set="method" line="244"><f a="a:b">
	<c path="massive.mcover.data.Package"/>
	<c path="massive.mcover.data.Package"/>
	<c path="Int"/>
</f></sortOnPackageId>
		<hxSerialize set="method" line="249" override="1"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize set="method" line="259" override="1"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new public="1" set="method" line="49"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="Type" params="" file="/usr/lib/haxe/std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="Array"><c path="Int"/></c></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="Array"><c path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="356" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a single value and return it.
	</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><c path="Int"/></pos>
		<length><c path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="81"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<getResolver public="1" set="method" line="91"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<get get="inline" set="null" line="95"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<readDigits set="method" line="99"><f a=""><c path="Int"/></f></readDigits>
		<unserializeObject set="method" line="124"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="139"><f a="edecl:tag">
	<c path="Enum"><d/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="160"><f a=""><d/></f></unserialize>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.
	</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable is found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable] having [pred] returning true.
	</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.
	</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>
		Returns a list containing all items of 'a' followed by all items of 'b'
	</haxe_doc>
		</concat>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="massive.mcover.data.Package" params="" file="src/massive/mcover/data/Package.hx">
		<extends path="massive.mcover.data.AbstractNodeList"/>
		<appendResults set="method" line="40" override="1"><f a="to:from">
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></appendResults>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>
		If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.
	</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>
		Use constructor indexes for enums instead of names.
		This is less reliable but more compact.
	</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="416" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize a single value and return the string.
	</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<scount><c path="Int"/></scount>
		<useCache public="1"><e path="Bool"/></useCache>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeException public="1" set="method" line="397"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="massive.mcover.data.Method" params="" file="src/massive/mcover/data/Method.hx">
		<extends path="massive.mcover.data.AbstractNode"/>
		<statementsById><c path="IntHash"><c path="massive.mcover.data.Statement"/></c></statementsById>
		<branchesById><c path="IntHash"><c path="massive.mcover.data.Branch"/></c></branchesById>
		<addStatement public="1" set="method" line="47"><f a="value">
	<c path="massive.mcover.data.Statement"/>
	<e path="Void"/>
</f></addStatement>
		<addBranch public="1" set="method" line="52"><f a="value">
	<c path="massive.mcover.data.Branch"/>
	<e path="Void"/>
</f></addBranch>
		<getStatementById public="1" set="method" line="57"><f a="id">
	<c path="Int"/>
	<c path="massive.mcover.data.Statement"/>
</f></getStatementById>
		<getBranchById public="1" set="method" line="63"><f a="id">
	<c path="Int"/>
	<c path="massive.mcover.data.Branch"/>
</f></getBranchById>
		<lookupBranch public="1" set="method" line="69" override="1"><f a="path">
	<c path="Array"><c path="Int"/></c>
	<c path="massive.mcover.data.Branch"/>
</f></lookupBranch>
		<lookupStatement public="1" set="method" line="76" override="1"><f a="path">
	<c path="Array"><c path="Int"/></c>
	<c path="massive.mcover.data.Statement"/>
</f></lookupStatement>
		<getMissingBranches public="1" set="method" line="83" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Branch"/></c></f></getMissingBranches>
		<getMissingStatements public="1" set="method" line="93" override="1"><f a=""><c path="Array"><c path="massive.mcover.data.Statement"/></c></f></getMissingStatements>
		<getResults public="1" set="method" line="102" override="1"><f a="?cache">
	<e path="Bool"/>
	<t path="massive.mcover.data.CoverageResult"/>
</f></getResults>
		<hxSerialize set="method" line="126" override="1"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize set="method" line="133" override="1"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new public="1" set="method" line="39"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="massive.mcover.Exception" params="" file="src/massive/mcover/Exception.hx">
		<type public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The exception type. 
	 * 
	 * Should be the fully qualified name of the Exception class. e.g. 'massive.io.IOException'
	 </haxe_doc>
		</type>
		<message public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * A description of the exception
	 </haxe_doc>
		</message>
		<info public="1" set="null">
			<t path="haxe.PosInfos"/>
			<haxe_doc>
	 * The pos infos from where the exception was created.
	 </haxe_doc>
		</info>
		<cause public="1" set="null">
			<d/>
			<haxe_doc>
	* An optional reference to a lower level exception that
	* triggered the current exception to be thrown
	</haxe_doc>
		</cause>
		<causeExceptionStack public="1" set="null"><c path="Array"><e path="haxe.StackItem"/></c></causeExceptionStack>
		<causeCallStack public="1" set="null"><c path="Array"><e path="haxe.StackItem"/></c></causeCallStack>
		<toString public="1" set="method" line="85">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[
	 * Returns a string representation of this exception.
	 * 
	 * Format: <type>: <message> at <className>#<methodName> (<lineNumber>)
	 ]]></haxe_doc>
		</toString>
		<here set="method" line="97"><f a="?info">
	<t path="haxe.PosInfos"/>
	<t path="haxe.PosInfos"/>
</f></here>
		<new public="1" set="method" line="66">
			<f a="message:?cause:?info">
				<c path="String"/>
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * @param	message			a description of the exception
	 </haxe_doc>
		</new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.mcover.AllClasses" params="" file="src/massive/mcover/AllClasses.hx">
		<main public="1" set="method" line="26" static="1"><f a=""><c path="massive.mcover.AllClasses"/></f></main>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Resource" params="" file="/usr/lib/haxe/std/haxe/Resource.hx">
		<content static="1"><c path="Array"><a>
	<str><c path="String"/></str>
	<name><c path="String"/></name>
	<data><c path="String"/></data>
</a></c></content>
		<listNames public="1" set="method" line="31" static="1"><f a=""><c path="Array"><c path="String"/></c></f></listNames>
		<getString public="1" set="method" line="38" static="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getString>
		<getBytes public="1" set="method" line="52" static="1"><f a="name">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
	</class>
	<class path="massive.mcover.CoverageLogger" params="" file="src/massive/mcover/CoverageLogger.hx" interface="1">
		<completionHandler public="1"><f a="">
	<c path="Float"/>
	<e path="Void"/>
</f></completionHandler>
		<allClasses public="1" set="null"><c path="massive.mcover.data.AllClasses"/></allClasses>
		<currentTest public="1" set="set_currentTest"><c path="String"/></currentTest>
		<report public="1" set="method"><f a="?skipClients">
	<e path="Bool"/>
	<e path="Void"/>
</f></report>
		<reportCurrentTest public="1" set="method"><f a="?skipClients">
	<e path="Bool"/>
	<e path="Void"/>
</f></reportCurrentTest>
		<addClient public="1" set="method">
			<f a="client">
				<c path="massive.mcover.CoverageReportClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Add a coverage clients to interpret coverage results.
	 * 
	 * @param client  client to interpret coverage results 
	 * @see massive.mcover.CoverageReportClient
	 * @see massive.mcover.client.PrintClient
	 </haxe_doc>
		</addClient>
		<removeClient public="1" set="method"><f a="client">
	<c path="massive.mcover.CoverageReportClient"/>
	<e path="Void"/>
</f></removeClient>
		<getClients public="1" set="method"><f a=""><c path="Array"><c path="massive.mcover.CoverageReportClient"/></c></f></getClients>
		<initializeAllClasses public="1" set="method"><f a="?resourceName">
	<c path="String"/>
	<e path="Void"/>
</f></initializeAllClasses>
		<logStatement public="1" set="method"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></logStatement>
		<logBranch public="1" set="method"><f a="id:value:?compareValue">
	<c path="Int"/>
	<d/>
	<d/>
	<d/>
</f></logBranch>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.mcover.CoverageLoggerImpl" params="" file="src/massive/mcover/CoverageLogger.hx" module="massive.mcover.CoverageLogger">
		<implements path="massive.mcover.CoverageLogger"/>
		<__meta__ public="1" line="85" static="1"><d/></__meta__>
		<completionHandler public="1">
			<f a="">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Handler called when all clients 
	 * have completed processing the results.
	 </haxe_doc>
		</completionHandler>
		<allClasses public="1" set="null"><c path="massive.mcover.data.AllClasses"/></allClasses>
		<currentTest public="1" set="set_currentTest"><c path="String"/></currentTest>
		<allStatementResultsById><c path="IntHash"><c path="Int"/></c></allStatementResultsById>
		<allBranchResultsById><c path="IntHash"><t path="massive.mcover.data.BranchResult"/></c></allBranchResultsById>
		<testStatementResultsById><c path="IntHash"><c path="Int"/></c></testStatementResultsById>
		<testBranchResultsById><c path="IntHash"><t path="massive.mcover.data.BranchResult"/></c></testBranchResultsById>
		<clients><c path="Array"><c path="massive.mcover.CoverageReportClient"/></c></clients>
		<clientCompleteCount><c path="Int"/></clientCompleteCount>
		<report public="1" set="method" line="134"><f a="?skipClients">
	<e path="Bool"/>
	<e path="Void"/>
</f></report>
		<reportCurrentTest public="1" set="method" line="144"><f a="?skipClients">
	<e path="Bool"/>
	<e path="Void"/>
</f></reportCurrentTest>
		<generateReportResults set="method" line="155"><f a="?currentTestOnly">
	<e path="Bool"/>
	<e path="Void"/>
</f></generateReportResults>
		<addClient public="1" set="method" line="177"><f a="client">
	<c path="massive.mcover.CoverageReportClient"/>
	<e path="Void"/>
</f></addClient>
		<removeClient public="1" set="method" line="188"><f a="client">
	<c path="massive.mcover.CoverageReportClient"/>
	<e path="Void"/>
</f></removeClient>
		<getClients public="1" set="method" line="194"><f a=""><c path="Array"><c path="massive.mcover.CoverageReportClient"/></c></f></getClients>
		<initializeAllClasses public="1" set="method" line="200"><f a="?resourceName">
	<c path="String"/>
	<e path="Void"/>
</f></initializeAllClasses>
		<logStatement public="1" set="method" line="220">
			<f a="id">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* Method called from injected code each time a code block executes. 
	* Developers should not class this method directly.
	</haxe_doc>
		</logStatement>
		<updateStatementHash set="method" line="234"><f a="hash:id">
	<c path="IntHash"><c path="Int"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></updateStatementHash>
		<logBranch public="1" set="method" line="253">
			<f a="id:value:?compareValue">
				<c path="Int"/>
				<d/>
				<d/>
				<d/>
			</f>
			<haxe_doc>
	* Method called from injected code each time a binary operation resolves to true or false 
	* Developers should not class this method directly.
	* @param id				branch id
	* @param value 			boolean or value to compare with compareValue
	* @param compareValue	secondary value to compare with
	</haxe_doc>
		</logBranch>
		<updateBranchHash set="method" line="280"><f a="hash:id:value">
	<c path="IntHash"><t path="massive.mcover.data.BranchResult"/></c>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></updateBranchHash>
		<set_currentTest set="method" line="303"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_currentTest>
		<reportToClients set="method" line="312"><f a=""><e path="Void"/></f></reportToClients>
		<clientCompletionHandler set="method" line="327"><f a="client">
	<c path="massive.mcover.CoverageReportClient"/>
	<e path="Void"/>
</f></clientCompletionHandler>
		<executeCompletionHandler set="method" line="341"><f a=""><e path="Void"/></f></executeCompletionHandler>
		<new public="1" set="method" line="127"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="massive.mcover.MCover" params="" file="src/massive/mcover/MCover.hx">
		<__meta__ public="1" line="60" static="1"><d/></__meta__>
		<VERSION public="1" line="62" static="1"><c path="String"/></VERSION>
		<RESOURCE_DATA public="1" line="63" static="1"><c path="String"/></RESOURCE_DATA>
		<logger public="1" set="null" static="1"><c path="massive.mcover.CoverageLogger"/></logger>
		<getLogger public="1" set="method" line="74" static="1"><f a=""><c path="massive.mcover.CoverageLogger"/></f></getLogger>
		<haxe_doc>
* Main Coverage class containing macro and runtime  methods for creating,
* logging and reporting code coverage.
* 
* MACRO USAGE:
*
* Use --macro massive.mcover.MCover.include('package.name',['sourcePath'])
* to specifiy which packages/src directories to cover
* 
* 
* RUNTIME USAGE:
*
* See detailed documentation below for the following:
*    getInstance();
*    createReporter();
</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/IntHash.hx" extern="1">
		<set public="1" set="method">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="massive.mcover.data.Statement" params="" file="src/massive/mcover/data/Statement.hx">
		<extends path="massive.mcover.data.AbstractBlock"/>
		<count public="1"><c path="Int"/></count>
		<isCovered public="1" set="method" line="41" override="1"><f a=""><e path="Bool"/></f></isCovered>
		<hxSerialize set="method" line="49" override="1"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize set="method" line="55" override="1"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<typedef path="massive.mcover.data.CoverageResult" params="" file="src/massive/mcover/data/CoverageResult.hx">
		<a>
			<sc><c path="Int"/></sc>
			<s>
				<c path="Int"/>
				<haxe_doc>
	*	statement total;
	</haxe_doc>
			</s>
			<pc>
				<c path="Int"/>
				<haxe_doc>
	*	package count;
	</haxe_doc>
			</pc>
			<p>
				<c path="Int"/>
				<haxe_doc>
	*	package total;
	</haxe_doc>
			</p>
			<mc>
				<c path="Int"/>
				<haxe_doc>
	*	method count;
	</haxe_doc>
			</mc>
			<m>
				<c path="Int"/>
				<haxe_doc>
	*	method total;
	</haxe_doc>
			</m>
			<fc>
				<c path="Int"/>
				<haxe_doc>
	*	file count;
	</haxe_doc>
			</fc>
			<f>
				<c path="Int"/>
				<haxe_doc>
	*	file total;
	</haxe_doc>
			</f>
			<cc>
				<c path="Int"/>
				<haxe_doc>
	*	class count;
	</haxe_doc>
			</cc>
			<c>
				<c path="Int"/>
				<haxe_doc>
	*	class total;
	</haxe_doc>
			</c>
			<bt>
				<c path="Int"/>
				<haxe_doc>
	*	branch true count;
	</haxe_doc>
			</bt>
			<bf>
				<c path="Int"/>
				<haxe_doc><![CDATA[
	*	branch count (true and false count both > 0);
	]]></haxe_doc>
			</bf>
			<bc>
				<c path="Int"/>
				<haxe_doc>
	*	branch false count;
	</haxe_doc>
			</bc>
			<b>
				<c path="Int"/>
				<haxe_doc>
	*	branch total;
	</haxe_doc>
			</b>
		</a>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</typedef>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="Int"/></c></typedef>
	<enum path="massive.munit.client.PrintLevel" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/client/PrintClient.hx" module="massive.munit.client.PrintClient">
		<NONE/>
		<FAILURE/>
		<ERROR/>
	</enum>
	<class path="massive.munit.TestResult" params="" file="/usr/lib/haxe/lib/munit/0,9,1,7/massive/munit/TestResult.hx">
		<passed public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether the test passed or not.
	 </haxe_doc>
		</passed>
		<executionTime public="1">
			<c path="Float"/>
			<haxe_doc>
	 * The execution time of the test in milliseconds.
	 </haxe_doc>
		</executionTime>
		<name public="1">
			<c path="String"/>
			<haxe_doc>
	 * The name of the test. This maps to the name of the test method.
	 </haxe_doc>
		</name>
		<className public="1">
			<c path="String"/>
			<haxe_doc>
	 * The name of the class (qualified with package) where the test is located.
	 </haxe_doc>
		</className>
		<description public="1">
			<c path="String"/>
			<haxe_doc>
     * An optional description.
     </haxe_doc>
		</description>
		<location public="1" get="get_location" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The fully qualified location of this test. (i.e. package.ClassName#method)
	 </haxe_doc>
		</location>
		<get_location set="method" line="68"><f a=""><c path="String"/></f></get_location>
		<async public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether the test is asynchronous or not.
	 </haxe_doc>
		</async>
		<ignore public="1">
			<e path="Bool"/>
			<haxe_doc>
     * Whether the test is ignored or not.
     </haxe_doc>
		</ignore>
		<failure public="1">
			<c path="massive.munit.AssertionException"/>
			<haxe_doc>
	 * If this test failed, the assertion exception that was captured.
	 </haxe_doc>
		</failure>
		<error public="1">
			<d/>
			<haxe_doc>
	 * If this test was erroneous, the error that was captured.
	 </haxe_doc>
		</error>
		<new public="1" set="method" line="96">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Class constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * The value object which contains the result of a test.
 * 
 * @author Mike Stead
 </haxe_doc>
	</class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/Hash.hx" extern="1">
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="massive.mcover.util.Timer" params="" file="src/massive/mcover/util/Timer.hx">
		<delay public="1" set="method" line="143" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="massive.mcover.util.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="158" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 *	Returns a timestamp, in seconds
	 </haxe_doc>
		</stamp>
		<run public="1"><f a=""><e path="Void"/></f></run>
		<id><t path="Null"><c path="Int"/></t></id>
		<defaultRun set="method" line="92"><f a=""><e path="Void"/></f></defaultRun>
		<stop public="1" set="method" line="95"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method" line="72"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>**
* Copyright 2011 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
</haxe>